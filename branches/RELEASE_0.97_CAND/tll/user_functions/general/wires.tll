
/*
 * helper functions
 *
 * Copyright (C) 2010 by Armin Taschwer
 *
 * Functions
 * ---------
 * void addwire_on_grid (point list pl, real width, bool fullypoly);
 * void placeVIAarray  (point leftbot, point righttop, int startlay, int stoplay);


 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA

 */

// following files need to be included BEFORE including this file !!

/* instead of default_drc you may also use a customized drc file */
//#include "default_drc.tll"
//#include "helper.tll"


/* creates a wire which is an polygon but all corners are on-grid
 * @param pl list of center-points 
 * @param width width of the wire
 * @param fullypoly if true the whole wire will be drawn as
 * polygon (attention! self-crossing edges may be the result). in case
 * of false the wire is separated into sections which are never self-crossing!
 */
void addwire_on_grid (point list pl, real width, bool fullypoly) {

  int nb = length (pl); //number of points
  real hw = width/2.0;
  point list poly; //list of points for drawing the final polygon 
  point p1,p2,p3;
  real a,b2,x;

  if (nb < 2) {
	echo("Warning: function doesn't work with one point");
	return;
  }

  //catches the case when pl is a polygon
  // if ( points_equal (pl[0], pl[nb-1])) {
  // 	pl[:-]; 
  // 	nb = nb - 1;
  // }

  p1 = vec_normal( pl[1] - pl[0] ) * hw;
  poly[:+] = round_to_grid (p1 + pl[0]);
  poly[+:] = round_to_grid (vec_mirror(p1) + pl[0]);

  if (nb > 2) {
	int nn = nb -2;
	foreach ( int n; seq(1,nn) ) {
	  p1 = vec_normal(pl[n] - pl[n-1]) * hw;
	  p2 = vec_normal(pl[n+1] - pl[n]) * hw;
	  p3 = (p1 + p2)/2;

	  //echo(p1); echo(p2);echo (p3);

	  // (p1 + p2)/2 .. is in relation to the corner (it points to the
      // corner) 
      // b/a = x/b  .. x is the difference between upper point and
      // corner (strahlensatz)
	  // --> x = b^2/a
      // refer to "wire_corn_calc.png"
	  a = vec_len (p3);
      b2 =  pow(hw,2) - pow(a,2);
	  x = b2 / a;
	  p3 = p3*(x/a + 1);

	  // echo (p3);
	  // echo (a); echo(b2); echo(x);
	  //echo (pl[n] + p3);
	  //echo (vec_mirror(p3) + pl[n]);
	  poly[:+] = round_to_grid(pl[n] + p3);
	  poly[+:] = round_to_grid(vec_mirror(p3) + pl[n]);
	  if ( ! fullypoly) {
		addpoly(poly);
		poly[1:-2]; //removes two points from the middle of the list
	  }
	}
  }

  p1 = vec_normal( pl[nb-1] - pl[nb-2] ) * hw;
  poly[:+] = round_to_grid (p1 + pl[nb-1]);   
  poly[+:] = round_to_grid (vec_mirror(p1)+ pl[nb-1]);

  //echo (poly);
  addpoly (poly);
}


/* ATTENTION placeVIAarray:
 * needs a technology file (at least default_drc.tll) to be included!
 */

/*
 * draws an array on vias into a rectangle defined by leftbot and
 * righttop
 * @param leftbot coordinates for left-bottom corner of the rectangle
 * @param righttop coordinates for right-top corner of the rectangle
 * @param startlay .. specifies the lowest metal layer (1 to 4) to
 * start with the contact. Be sure that your layer definitions contain 
 * layers with name MET1 to MET4 and VIA1 to VIA3
 * @param stoplay .. specifies the highest metal layer which has to be
 * contacted 
 */
void placeVIAarray (point leftbot, point righttop, int startlay, int stoplay) {
  
  point via_spc = {VIA_SPC,VIA_SPC};
  point via = { VIA, VIA };
  box via_bx = { {0,0}, via };

  point lb = leftbot;
  point rt = righttop;

  //check input range
  if (leftbot.x > righttop.x) { 
	lb.x = righttop.x;
	rt.x = leftbot.x;
  }
  if (leftbot.y > righttop.y) {
	lb.y = righttop.y;
	rt.y = leftbot.y;
  }


  point t_dist = vec_abs (rt - lb);
  point dist = t_dist - (via_spc*2.0 + via); // diagonal without
                                             // last VIAs+space  

  /*   x...x...x...x   --> x == vias, . == spaces */
  int xx = floor(EPS + dist.x / (VIA+VIA_SPC)); //number of vias & spaces - 1 via
  real spcx = (dist.x - xx*VIA)/xx; //max. space between two vias
  
  int yy = floor(EPS + dist.y / (VIA+VIA_SPC)); //number of vias & spaces - 1 via
  real spcy = (dist.y - yy*VIA)/yy; //max. space between two vias

  point spcgrid = floor_to_grid ( {spcx, spcy} );

  int alay = startlay;
  int zlay = stoplay;

  if (startlay > stoplay) {
	alay = stoplay;
	zlay = startlay;
  }

  //debug
  // echo(lb); echo(rt);
  // echo(vec_abs(rt-lb));
  // echo(dist);
  // echo(spcx);echo(spcy);
  // echo(spcgrid);
  // echo( "xx: " );echo( xx );
  // echo( "yy: " );echo( yy );
  // echo( "alay ");echo(alay);
  // echo( "zlay ");echo(zlay);
  
  if (spcgrid.x < VIA_SPC) {
	echo ("WARNING: found DRC violation for X-spacing -- abort function");
	echo ("  spcgrid: "); echo (spcgrid);
	return;
  } else {
	if (spcgrid.y < VIA_SPC) {
	  echo ("WARNING: found DRC violation for Y-spacing -- abort function");
	  echo ("  spcgrid: "); echo (spcgrid);
	  return;
	} 
  }

  int break = 0; //if break == 1 : do not draw any vias

  foreach (int lay; seq(alay,zlay) ) {
	//debug
	//echo (lay);

	if (lay == 1) {
	  usinglayer ("MET1");
	  addbox ( { lb, rt } );
	  if (lay >= zlay) { break = 1; }
	  else {
		usinglayer ("VIA1");
	  }
	}

	if (lay == 2) {
	  usinglayer ("MET2");
	  addbox ( { lb, rt } );
	  if (lay >= zlay) { break = 1; }
	  else {
		usinglayer ("VIA2");
	  }
	}
	if (lay == 3) {
	  usinglayer ("MET3");
	  addbox ( { lb, rt } );
	  if (lay >= zlay) { break = 1; }
	  else {
		usinglayer ("VIA3");
	  }
	}
	if (lay == 4) {
	  usinglayer ("MET4");
	  addbox ( { lb, rt } );
	  break = 1; 
	}

	if ( break == 0 ) {
	  int exx = xx+1;
	  int eyy = yy+1;
	  real px,py;
	  point newp, residue;

	  foreach (int x; seq (1,exx) ) {
		foreach (int y; seq (1,eyy) ) {
		  px = (VIA+spcgrid.x)*(x-1);
		  py = (VIA+spcgrid.y)*(y-1);
		  newp = { px, py};
		  residue = t_dist - newp + via_spc;
		  if (residue.x < VIA_SPC) {
			echo ("WARNING: found DRC violation in X-direction -- VIA will not drawn");
			//echo (rt); echo (newp); echo (rt - newp);
			echo ("  residue: "); echo (residue);
			echo ("  spcgrid: "); echo (spcgrid);
		  } else {
			if (residue.y < VIA_SPC) {
			  echo ("WARNING: found DRC violation in Y-direction -- VIA will not drawn");
			  //echo (rt); echo (newp); echo (rt - newp);
			  echo ("  residue: "); echo (residue);
			  echo ("  spcgrid: "); echo (spcgrid);
			} else {
			  addbox ( via_bx + lb + via_spc + newp );
			}
		  }
		}
	  }
	} else {
	  lay = zlay + 1;
	}
  }
}
