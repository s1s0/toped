#A memo about the amount of memory taken by the objects

= Heap size of a Linux process =

Any optimisation task requires some kind of criteria. To optimize the memory footprint of Toped DB we need a simple and reliable measurement of the amount of heap memory allocated by the tool. After some research on the net and multiply tries with C libraries, external tolls, commands, scripts etc. I actually realised (surprise surprise!) that Kernel memory management these days appears to be quite a complex task and extracting the tiny bit of data that I needed out of the OS proves to be a real challenge. Besides it appeared that there are a variety of OS environmental factors that influence those reports - most of them not easily if at all controllable. A small snapshot of my adventures below

  * OS commands (ps, top) - see [http://virtualthreads.blogspot.com/2006/02/understanding-memory-usage-on-linux.html Understanding memory usage on Linux]
  * reading `proc/<pid>/status` - not surprisingly it appears to be not quite different from the above
  * getrusage() - I manage to squeeze literally nothing about the memory out of this function - then I found [http://www.atarininja.org/index.py/tags/code this]. It appeared that vital parts of *struct rusage* fields are simply not implemented on my platform.
  * external tools/libraries - [http://valgrind.org valgrind], [http://directory.fsf.org/project/ElectricFence efence], [http://dmalloc.com dmalloc] . They seem to be either too heavy or not quite up to this particular task.
  * scripts - most of what I found, not surprisingly is actually exploring the features already listed above. It's worth mentioning though [Object_memory_size#smaps] script which seem to be relatively simple to create/install and generates descent reports. Still though it suffers the same lack of clarity "what's what" which of course is due to the overall Kernel memory management. Some interesting observations:
      * Heap is allocated on pages. It's virtually impossible to spot a creation of a single small object.
      * I couldn't find a way to distinguish between the heap used by the program itself, and the heap used by the linked libraries. 
      * Heap is deallocated when required, not when a delete/free is executed. This often creates the impression that heap is an ever growing resource consumed by your program. When the unused heap will be claimed back by the OS and granted to another process is entirely due to the Kernel.

So - the task has to be approached from a different angle.




= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages

= smaps =
This script can be found on the net, but with some broken links to the required perl modules. Here are they:
   * [http://search.cpan.org/~opi/Class-Member-1.6/ Class-Member]
   * [http://search.cpan.org/~opi/Linux-Smaps-0.06/ Smaps]

Here is also the script itself:
{{{
#!/usr/bin/perl
#smaps.pl
#typical usage is as follows :
# smaps.pl pid

use Linux::Smaps;

my $pid=shift @ARGV;
unless ($pid) {
        print "./smem.pl <pid>\n";
        exit 1;
}
my $map=Linux::Smaps->new($pid);
my @VMAs = $map->vmas;

format STDOUT =
VMSIZE:  @######## kb
$map->size
RSS:    @######## kb total
$map->rss
        @######## kb shared
$map->shared_clean + $map->shared_dirty
        @######## kb private clean
$map->private_clean
        @######## kb private dirty
$map->private_dirty
.

write;

printPrivateMappings ();
printSharedMappings ();

sub sharedMappings () {
    return grep { ($_->shared_clean  + $_->shared_dirty) > 0 } @VMAs;
}

sub privateMappings () {
    return grep { ($_->private_clean  + $_->private_dirty) > 0 } @VMAs;
}

sub printPrivateMappings ()
{
    $TYPE = "PRIVATE MAPPINGS";
    $^ = 'SECTION_HEADER';
    $~ = 'SECTION_ITEM';
    $- = 0;
    $= = 100000000;
    foreach  $vma (sort {-($a->private_dirty <=> $b->private_dirty)}
                                  privateMappings ()) {
        $size  = $vma->size;
        $dirty = $vma->private_dirty;
        $clean = $vma->private_clean;
        $file  = $vma->file_name;
        write;
    }
}

sub printSharedMappings ()
{
    $TYPE = "SHARED MAPPINGS";
    $^ = 'SECTION_HEADER';
    $~ = 'SECTION_ITEM';
    $- = 0;
    $= = 100000000;

    foreach  $vma (sort {-(($a->shared_clean + $a->shared_dirty)
                          <=>
                          ($b->shared_clean + $b->shared_dirty))}
                  sharedMappings ()) {

        $size  = $vma->size;
        $dirty = $vma->shared_dirty;
        $clean = $vma->shared_clean;
        $file  = $vma->file_name;
        write;
    }
}

format SECTION_HEADER =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$TYPE
@>>>>>>>>>> @>>>>>>>>>>  @>>>>>>>>>  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
"vmsize" "rss clean" "rss dirty" "file"
.

format SECTION_ITEM =
@####### kb @####### kb @####### kb  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$size $clean $dirty $file
.
}}}
