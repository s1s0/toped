

/* 
 * functions to generate different kind of caps
 *
 * Copyright (C) 2011 by Armin Taschwer
 *
 *
 */
 
 
 
/* simple fingercaps
 * @param area describes the area into which the finger-cap should be places
 * @param startlayer lowest metal layer (1 .. M1, 2 .. M2, ..)
 * @param endlayer highest metal layer
 */
void draw_finger_cap ( box b, int startlayer, int endlayer ) {

  real max_min_w = 0;
  real max_min_s = 0;

  int sl = startlayer;
  int el = endlayer;

  if (startlayer > endlayer) {
    el = startlayer;
    sl = endlayer;
  }
  if (sl > MAX_METAL) return;
  if (el > MAX_METAL) el = MAX_METAL;

  // check for the largest minimal wire width / space
  foreach (int i; seq(sl,el) ) {
    if (i == 1) {
      max_min_w = M1_MIN_W;
      max_min_s = M1_MIN_S;
    } else if (i == 2) {
      if (max_min_w < M2_MIN_W) max_min_w = M2_MIN_W;
      if (max_min_s < M2_MIN_S) max_min_s = M2_MIN_S;
    } else if (i == 3) {
      if (max_min_w < M3_MIN_W) max_min_w = M3_MIN_W;
      if (max_min_s < M3_MIN_S) max_min_s = M3_MIN_S;
    } else if (i == 4) {
      if (max_min_w < M4_MIN_W) max_min_w = M4_MIN_W;
      if (max_min_s < M4_MIN_S) max_min_s = M4_MIN_S;
    }
    //needs to gone if more metals are needed!
  }

  //fingers are always oriented from north to south
  int n_finger = floor((box_width (b) - max_min_w) / (2*max_min_w + 2*max_min_s));
  int n_finger_p_1 = n_finger + 1;

  real len_finger = box_height (b) - max_min_w*2 - max_min_s;

  // echo (n_finger);
  // echo (max_min_w);
  // echo (max_min_s);
  // echo (box_height(b));
  // echo (len_finger);


  real y_start;       //
  real x,y;           //changing y values
  real fac;           // -1 if y_start is minimal, otherwise 1
  real x_start = r_min (b.p1.x, b.p2.x);
  point list comb;

  foreach (int i ; seq (sl,el)) {
    // set layer
    if (i == 1) usinglayer ("MET1");
    if (i == 2) usinglayer ("MET2");
    if (i == 3) usinglayer ("MET3");
    if (i == 4) usinglayer ("MET4");

    if ( fmod(i,2) == 0 ) {
      y_start = r_max (b.p1.y, b.p2.y);
      fac = 1;
    } else {
      y_start = r_min (b.p1.y, b.p2.y);
      fac = -1;
    }

    //upper comb (lower comp resp.)
    x = x_start;
    y = y_start;
    foreach (int j; seq(1,n_finger_p_1)) {
      if (j == 1) { 
	comb[:+] = { x_start, y_start };
	y = y_start - fac*(len_finger + max_min_w);
      } else {
	comb[:+] = { x, y };
	y = y - fac*(len_finger);
      }
	
      comb[:+] = { x, y }; x = x + max_min_w;
      comb[:+] = { x, y }; y = y + fac*len_finger;
      comb[:+] = { x, y }; x = x + max_min_w + 2*max_min_s;
	
      if (j == n_finger_p_1) {
	comb[:+] = { x - max_min_w - 2*max_min_s, y_start };
      }
    }
    addpoly (comb);

    comb = {}; //delete contents

    //lower comp (upper comp resp.)
    x = x_start;
    y_start = y_start - fac*(box_height(b));
    fac = -1 * fac;

    foreach (int j; seq(1,n_finger_p_1)) {
      if (j == 1) { 
	comb[:+] = { x_start, y_start };
	y = y_start - fac*(max_min_w);
	comb[:+] = { x_start, y };
	x = x_start + max_min_w + max_min_s;
      } else if ( j == n_finger_p_1) {
	comb[:+] = { x, y };
	x = x + max_min_s + max_min_w;
      } else {
	comb[:+] = { x, y };
	x = x + 2*max_min_s + max_min_w;
      }
	
      comb[:+] = { x, y }; y = y - fac*len_finger;
      comb[:+] = { x, y }; x = x + max_min_w;
      comb[:+] = { x, y }; y = y + fac*len_finger;
      
	
      if (j == n_finger_p_1) {
	comb[:-];
	comb[:-];
	comb[:+] = { x - max_min_w, y_start };
      }
    }
    //echo(comb);
    addpoly (comb);

    comb = {}; //delete contents
  } 
}
